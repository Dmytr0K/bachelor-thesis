\chapter{РЕАЛИЗАЦИЯ СИСТЕМЫ УПРАВЛЕНИЯ ДВИЖЕНИЕМ БЕСПИЛОТНОГО АВТОМОБИЛЯ}
В этой главе рассматривается реализация системы управления движением беспилотного автомобиля на основе разработанного
в предыдущей главе алгоритма, а также создание модели автомобиля для тестирования и отработки системы.

\section{Использование ROS в качестве основы для системы управления}
Разработка комплексного программного обеспечения, которым является система управления беспилотным автомобилем ~---
сложная и объемная задача. Система управления состоит из ряда модулей, которые должны взаимодействовать друг с другом.
Также требуется обеспечить работу с внешними устройствами, такими как стереокамера и LiDAR. Система управления должна
состоять из следующих модулей:
\begin{itemize}
    \item модуль получения видео со стереокамеры,
    \item модуль получения облака точек с LiDAR,
    \item модуль, реализующий алгоритм SLAM для определения положения и ориентации автомобиля в пространстве с помощью
          стероекамеры,
    \item модуль планирования движения,
    \item модуль движения по программной траектории,
    \item модуль управления двигателями,
    \item модуль пользовательского интерфейса для управления, визуализации и отладки системы.
\end{itemize}

Как видно, система состоит из большого числа модулей, для части из которых (работа с камерой и LiDAR, алгоритм SLAM)
существуют готовые реализации. Необходимо реализовать модули достаточно независимыми, чтобы обеспечить легкость тестирования
и возможность дальнейшего расширения и модернизации системы, что требует реализации способа взаимодействия между модулями.

Эта проблема широко распространена в сфере робототехники, и существует ряд решений, облегчающих разработку. Одним из
таких решений является Robot Operation System (ROS) \cite{ros}.

Robot Operating System ~--- это гибкий фреймворк для написания программного обеспечения для роботов. Он включает в себя
набор инструментов, библиотек и соглашений, направленных на упрощение создания сложных систем управления для широкого
класса робототехнических платформ. ROS является одним из самых широко распространенных фреймворком для разработки
программного обеспечения для робототехнических систем.

Использование ROS обладает рядом преимуществ, таких как:
\begin{itemize}
    \item поддерживает модульную и распределенную архитектуру приложений;
    \item обладает готовыми удобными механизмами взаимодействия между модулями;
    \item имеет большое количество утилит и инструментов, таких как программы с графическим интерфейсом, для отображения
          множества данных (изображения, облака точек, траектории и т.д.), логгер, позволяющий записывать данные,
          передаваемые между модулями, и потом воспроизводить их для дальнейшего изучения и отладки, визуализатор
          модулей, из которых состоит система, система сборки, облегчающая компиляцию и многое другое;
    \item множество готовых библиотек для управления, компьютерного зрения и визуализации;
    \item подробная документация;
    \item обширное сообщество разработчиков.
\end{itemize}

В основе ROS лежит концепция узла или ноды (node). Нода ~--- это базовая единица построения ПО в ROS, программный модуль,
который выполняет определенное действие, например, работает с LiDAR и предоставляет облака точек, и представляет
собой отдельный процесс. Ноды взаимодействуют с помощью IPC (inter-process communication) механизмов, предоставляемых
ROS: топиков (ROS topic) и сервисов (ROS service). Ноды ROS могут быть реализованы на различных языках программирования.
Официально поддерживаются C++, Python 2.7 и Common Lisp, для этих языков реализованы клиентские библиотеки, позволяющие
получить доступ к возможностям ROS. Существуют клиентские библиотеки для других языков, таикх как C\#, Java, JavaScript,
Ruby, Lua, Go, но большинство из них не обновляются и не поддерживают современные версии ROS. Помимо этого, существует
пакет ROS "rosbridge\_suite", предоставляющий интерфейс ROS в виде JSON-API, что позволяет использовать ROS с любым языком,
в котором можно работать с сетью и JSON.

Топики реализуют механизм "издатель-подписчик". Топик является именованной типизированной FIFO очередью, в которую
ноды могут асинхронно записывать данные и считывать данные. Ноды, которые записывают данные в топик называются
издатель (publisher), а ноды, которые считывают данные из ноды, называются подписчик (subscriber). Несколько нод могут
одновременно писать и читать данные из одного топика.

Данные представляются в виде сообщений (messages). Сообщение
представляет собой структуру данных, которая может состоять из примитивных типов данных, таких как целые числа или
строки, и других типов данных, например, основанных на других сообщениях. Для описание сообщений в ROS применяются
файлы специального формата, в которых перечисляются все тип и название всех полей сообщения. На основе этих файлов
сборочная система ROS осуществляет генерацию кода для представления сообщения в поддерживаемых языках программирования.
Так, например, для C++ и Python создаются классы с соответствующими полями и внутренний вспомогательный код для сериализации
сообщений. ROS имеет большое количество встроенныхс стандартных типов сообщений, типичных для робототехники, такие как
изображение (sensors\_msgs/Image), облака точек (sensors\_msgs/PointCloud2), положение и кватернион ориентации
(geometry\_msgs/Pose), путь, как набор положений (nav\_msgs/Path), карта препятствий в виде сетки (nav\_msgs/OccupancyGrid)
и многие другие.

Преимуществом такого механизма является то, что отдельные ноды могут быть полностью независимы от других и не иметь
никакой информации о них. Например, для ноды, занимающающейся обработкой облака точек, совершенно не важно, получены
ли данные от LiDAR, камеры глубины, такой как Kinect, от стереокамеры или даже воспроизводятся из файла ~---
данные приходят в одинаковом стандартном формате.

Другим способом взаимодействия между нодами в ROS являются сервисы, реализующие механизм "запрос-ответ". В данном случае
одна нода выступает в роле сервиса, а другие ~--- в роли клиентов. Сервисы, в отличие, от топиков, являются синхронными,
т.е. нода, обратившаяся к сервису, ожидает ответа от него. Для описания сервисов также существует определенный формат
файла, в котором описываются типы и имена агументов, передаваемые клиентом сервису, и формат ответа от сервиса.
Таким образом, сервис реализует семантику удаленного вызова процедуры (Remote Procedure Call).

ROS обладает центральным узлом ~--- мастером (ROS Master), который отвечает за соединение между собой всех узлов ROS.
Мастер хранит информацию обо всех подписках, публикациях, сервисах и предоставляет эту информацию нодам. Взаимодействие
между нодами и мастером осуществляется по протоколу XML/RPC, дальнейшее взаимодействие нод между собой может осуществляться
по ряду протоколов, чаще всего применяется TCP.

На рисукне \ref{img:ros_topic_mechainism} приведена иллюстрация механизма установления соединения между двумя нодами
при использовании топиков.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{images/3_devel/ros_topic}
    \caption{Механизм работы топиков ROS}
    \label{img:ros_topic_mechainism}
\end{figure}

Нода, выступающая в роле издателя уведомляет об этом мастера, вызывая метод "advertise" с использованием протокола XML/RPC,
сообщая ему имя топика и тип сообщения. Нода, выступающая в качестве подписчика, отправляет запрос "subscribe" мастеру
с использованием протокола XML/RPC, сообщая имя топика, на который осуществляется подписка. В ответ мастер сообщает
данные для подключения к ноде-издателю. После этого нода-слушатель отправляет запрос "connect" ноде-издателю с
использованием протокола XML/RPC. В ответ нода-издатель сообщает данные (адрес и порт) для установления TCP-соединения.
После этого нода-подписчик осуществляет TCP-подключение к ноде-издателю и после этого нода-издатель может осуществлять
передачу данных.

Механизм работы сервисов приведен на рисунке \ref{img:ros_service_mechainism}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{images/3_devel/ros_service}
    \caption{Механизм работы топиков ROS}
    \label{img:ros_service_mechainism}
\end{figure}

В данном случае нода, выступающая в роли сервиса, уведомляет об этом мастера, вызывая метод "advertiseService" с
использованием протокола XML/RPC. Нода, использующая сервис, вначале запрашивает у мастера данные для вызова сервиса,
вызывая метод "lookupService" с использованием протокола XML/RPC. Мастер сообщает данные  для подключения (адрес и порт).
После этого, когда требуется вызвать сервис, нода устанавливает TCP-подключение, отправляет запрос и принимает ответ
от ноды-сервиса.

Существует два режима работы сервисов: с установлением соединения на каждый запрос (по-умолчанию), и с постоянным
соединением. Первый режим более надежен, т.к. позволит работать даже в случае перезапуска сервиса, а второй режим
обеспечивает меньшую латентность вызова сервиса. Результаты измерения латентности вызова сервиса в режиме повторного
подключения и режиме постоянного подключения в пределах localhost представлены на рисунке
\ref{img:rosservice_call_latency} и в таблице \ref{tab:rosservice_call_latency}. Из результатов измерения видно,
что постоянное подключение обеспечивает существенно меньшую латентность вызова и, что не менее важно, меньший
джиттер (разброс времени вызова), что особенно важно для систем реального времени.

\begin{figure}[h]
    \centering
    \includegraphics[]{images/3_devel/rosservice_call_latency}
    \caption{Механизм работы топиков ROS}
    \label{img:rosservice_call_latency}
\end{figure}

\begin{table}[h]
    \caption{Сравнение латентности вызова сервисов ROS в разных режимах}
    \label{tab:rosservice_call_latency}
    \begin{tabularx}{\textwidth}{|l|X|X|}
        \hline
                     & Повторное подключение, мс & Постоянное подключение, мс \\
        \hline
        Минимальное  & 1.2 & 0.1 \\
        \hline
        Среднее      & 3.1 & 0.4 \\
        \hline
        Максимальное & 9.5 & 1.1 \\
        \hline
    \end{tabularx}
\end{table}

\section{Постройка мобильной платформы}
Для испытаний и отладки системы управления движением беспилотного автомобиля была построена небольшая
модель автомобиля на базе шестиколесной платформы. Внешний вид модели представлен на рисунке
\ref{img:jetson_car}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/car}
    \caption{Внешний вид модели}
    \label{img:jetson_car}
\end{figure}

Модель построена на базе шестиколесной платформы Dagu Wild Thumper 6WD \cite{jetson_car_6wd}, оснащенной шестью
двигателями постоянного тока. Данная платформа кинематическую схему, которая отличается от кинематической схемы
обычного автомобиля (схемы Аккермана), управляется путем изменения относительной скорости вращения колес левого
и правого бортов, и, следовательно, способна на разворот на месте. Тем не менее, на начальном этапе испытаний
системы управления движением беспилотного автомобиля она позволяет провести ряд экспериментов и частично
отладить систему управления. Эта платформа была выбрана по причине того, что она была доступна на кафедре
ЭВМиС Волгоградского Государственного Университета. Двигатели левого и правого борта соединены параллельно
(по три двигателя в параллель) и подключены к управляются двумя драйверами VNH3SP30 \cite{jetson_car_driver}.

Для определения положения и ориентации автомобиля применяется алгоритм SLAM и стереокамера ZED Camera
\cite{jetson_car_zed} от компании Stereolabs. Камера обладает качественной оптикой с широким углом обзора в
90$\degsym$ и 60$\degsym$ по горизонтали и вертикали соответственно и максимальным суммарным разрешение двух
камер 4416х1242. В комплекте к камере поставляется программное обеспечение, реализующее ряд возможностей,
в том числе алгоритм SLAM, позволяющий отслеживать положение и ориентацию камеры в пространстве.
Производителем заявляется точность позиционирования в 1 мм и точность определения ориентации в 0.1$\degsym$,
но без уточнения условий, в которых получены такие результаты, потому что для алгоритмов SLAM характерно
накопление ошибки при увеличении пройденного расстояния. Помимо этого точность SLAM зависит от окружающего
пространства, наличия ключевых точек, которые могут быть детектированы, наличия подвижных объектов, которые
могут ввести алгоритм в заблуждение. Специальные эксперименты по оценке точности ZED-камеры не проводились, но
по результатам эксплуатации можно сделать вывод, что заявленные производителем характеристики не соблюдаются. Тем не
менее, ZED-камера показала хорошую точность при небольших перемещениях (в пределах помещений), достаточную для
проведения экспериментов с моделью беспилотного автомобиля.

Для определения препятствий применяется LiDAR Velodyne VLP-16. LiDAR позволяет получить
трехмерное облако точек, представляющее окружающую обстановку, обладающее сравнительно большой детализацией, обнаруживая
препятствия на расстояниях до ста метров. Качественное облако точек существенно облегчает задачу определения препятствий,
что позволяет сконцентрировать усилия на основной задаче данной работы ~--- разработке системы планирования движения.
Т.к. LiDAR уже был приобретен университетом для проекта беспилотного автомобиля, его использования выглядит оправданным.

В качестве бортового компьютера используется встраиваемая система NVidia Jetson TX2. Это встраиваемая система на базе
процессора с архитектурой ARM и встроенного графического ускорителя с архитектурой NVidia Pascal, предназначенная для
применения в задачах компьютерного зрения и нейронных сетей. Эта встраиваемая система обладает малым энергопотреблением,
что важно для мобильной платформы с питанием от аккумуляторных батарей, по сравнению с системами на базе x86 процессоров,
но, в то же время, достаточно высокой производительностью по сравнению с другими системами на базе ARM, такими как
Raspberry Pi. Наличие производительного GPU позволяет использовать ресурсоемкие алгоритмы. В данном случае, GPU используется
для работы алгоритма SLAM ZED-камеры, который реализован с использованием CUDA.

Питание мобильной платформы осуществляется от двух литий-полимерных аккумуляторов с напряжением 7.4 В (2S, две
аккумуляторных ячейки) и  12 В (3S, три аккумуляторных ячейки). Два аккумулятора применяются для раздельного питания
электроники (NVidia Jetson TX2 и LiDAR) и двигателей, чтобы исключить негативные влияния возможных импульсов напряжения
или просадок напряжения на чувствительную электронику.

Для управления двигателями применяется микроконтроллер STM32F103C8T6, который получает команды управления от
NVidia Jetson по интерфейсу UART. Отдельный микроконтроллер применяется по причине того, что NVidia Jetson не
имеет аппаратного ШИМ.

\section{Реализация подсистемы распознавание препятствий}
Для тестирования алгоритма планирования движения необходимо определять препятствия, которые будут объезжаться
моделью автомобиля. Детектирование препятствий осуществляется с помощью облака точек, получаемого от LiDAR,
а карта препятствий представляется в виде OccupancyGrid ~--- регулярной сетки, где каждая клетка может быть в одном
из трех состояний: неизвестно, есть препятствие, нет препятствия (более точно, клетка в OccupancyGrid определяет
вероятность нахождения препятствия в ней, но в данной работе вероятностный подход не применялся).

Первоначальный вариант алгоритма определения основывался на детектировании (сегментации) плоскости поверхности, что является
распространенным подходом для решения этой задачи. Самым простым способом сегментации плоскости является алгоритм
Random Sample Consensus (RANSAC) \cite{ransac}. Этот алгоритм позволяет осуществлять регрессию данных, в которых
присутствует большое количество выбросов. В результате алгоритм определяет находит параметры модели, а также
разделяет входные данные на удовлетворяющие модели (inliers) и выбросы (outliers).

Алгоритм работает следующим образом. На каждой итерации из общего набора экспериментальных данных $X$ выбирается
$M$ случайных точек $X_1$. Вычисляются параметры $\theta$ модели. Для задачи сегментации плоскости применяется
линейная регрессия. Затем, проверяется, какие точки общего набора данных $X$ отклоняются от модели не более, чем на
$p$. Отклоняющиеся точки помечаются как outliers, а соответствующие ~--- как inliers. Если количество инлаеров больше,
чем максимальное, то происходит обновление максимального числа инлаеров и коэффициентов модели. Алгоритм повторяется
$N$ итераций. Благодаря случайному выбору точек алгоритм RANSAC более устойчивый к выбросам, чем обычная линейная
регрессия. В работе использовалась реализация алгоритма RANSAC из библиотеки Point Cloud Library.

После сегментации облака точек и определения точек, принадлежащих плоскости и принадлежащих препятствиям, облако точек
преобразуется в OccupancyGrid. Для этого создается OccupancyGrid с размером, соответствующим размеру облака точек, и
заданным размером сетки, например, 0.25 м. Зная координату каждой точки, координату начала координат OccupancyGrid и
размер клетки, можно определить индекс клетки, к которой принадлежит точка:
\begin{align}
    p_i &= \floor{\frac{p_x - x_0}{cell\_size}} \\
    p_j &= \floor{\frac{p_y - y_0}{cell\_size}}
\end{align}

Клетка считается препятствием, если количество точек, отмеченных как препятствие, попавших в нее, превышает некое
установленное значение.

Velodyne VLP-16 обладает шестнадцатью лучами, кроме того, мобильная платформа обладает никой высотой, поэтому
количество точек в облаке точек, принадлежащих поверхности, мало. Это приводит к тому, если что считать допустимой для
движения областью только области, сегментированные как плоскость, то большая часть пространства не будет отмечена
как допустимая. Более эффективным способом будет считать все клетки с препятствиями как препятствия, а все прочие
клетки ~--- как свободные, исключая те, которые находятся "в тени". Для этого применяется метод трассировки луча
(ray casting) в 2D. От LiDAR до первой клетки препятствия все клетки считаются как свободные, затем идет клетка
препятствия, а далее все клетки помечаются как неизвестные. Т.к. OccupancyGrid представляет собой сетку, для трассировки
луча применяется алгоритм Брезенхема для растеризации линии, широко применяемый в компьютерной графике.

Помимо трассировки линий, вокруг каждой клетки препятствия растрируется окружность заданного радиуса, для того, чтобы
обеспечить безопасную зону вокруг препятствий. Благодаря этому при определении пересечения автомобиля с препятствием
можно считать автомобиль точечным. Данный метод не учитывает ориентацию автомобиля. Т.к. автомобиль имеет вытянутую
форму, приходится выставлять безопасный радиус по самому большому габариту модели, т.е. равному длине. Это приводит
к неэффективному использованию пространства, особенно в узких проходах. Результат работы алгоритма приведен на
рисунке \ref{img:obstacles_lidar}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/3_devel/obstacles_lidar}
    \caption{Результат работы алгоритма детектирования препятствий}
    \label{img:obstacles_lidar}
\end{figure}

Система детектирования препятствий была реализована в виде ноды ROS, которая подписана на топики облака точек и текущего
положение модели и публикует nav\_msgs/OccupancyGrid.

\section{Реализация подсистемы планирования траектории}

Система планирования траектории реализована в виде ноды ROS.
Нода подписывается на два топика: /car\_state и /next\_target. Топик /car\_state имеет тип нестандартный
сообщений car\_msgs/CarState и представляет текущее состояние автомобиля: положение, ориентацию, линейную скорость,
линейное ускорение. Топик /netx\_target имеет нестандартный тип car\_msgs/MotionPlanningTarget и представляет цель
для планирования движения: опорную траекторию, целевое положение, которое должно лежать на опорной траектории и
целевую скорость. Нода публикует найденную оптимальную траекторию в топик /local\_path, имеющий нестандартный
тип сообщения car\_msgs/CarMotion и содержит найденные путь, профиль скорости и ускорения в глобальной декартовой
системе координат, название которой указывается стандартным для ROS способом в поле frame\_id сообщения.

Прототип реализован на языке Python 2.7. Диаграмма классов системы планирования движения представлена на рисунке
\ref{img:motion_planner_classes}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/3_devel/motion_planner_classes}
    \caption{Интерфейс ноды планирования движения}
    \label{img:motion_planner_classes}
\end{figure}

Главным Классом является класс MotionPlanner, который реализует алгоритм планирования траектории и используется
из ноды motion\_planner\_node. Реализованы следующие вспомогательные классы: Quintic, Frenet, Trajectory1D,
Trajectory2D, Vertex. Класс Quintic отвечает за расчет коэффициентов полиномов пятого порядка и их интерполяцию.
Класс Frenet представляет систему координат Френе и осуществляет преобразование координат в эту систему и
обратно в глобальную декартову систему координат. Классы Trajectory1D и Trajectory2D представляют одномерную
(продольную либо поперечную) и двумерную (в системе координат Френе или в глобальной систесе координат) траектории
соответственно. Эти класс хранит траекторию, первую и вторую производную и рассчитанный вес этой траектории.
Класс Vertex представляет вершину графа и применяется в алгоритме Дейкстры.

Алгоритм планирования движения требует определения текущей скорости автомобиля, в то время как с помощью
SLAM алгоритма можно получить только текущие координаты. Для получения скорости была реализована нода car\_state\_publisher,
которая осуществляет численное дифференцирование получаемых от ZED-камеры координат для определения скорости.
Эксперименты показали, что результаты дифференцирования координат зашумлены. Для решения этой проблемы был применен
фильтр скользящей медианы. Пример исходных данных и результат фильтрации приведен на рисунке \ref{img:zed_calc_speed}.
На правом изображении приведены графики положения камеры по $x$- и $y$-координатам. На левом изображении приведены
графики скоростей, полученные путем дифференцирования положения, и отфильтрованные  с помощью фильтра скользящей
медианы.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{images/3_devel/zed_calc_speed}
    \caption{Результаты расчета скорости по данным с ZED-камеры}
    \label{img:zed_calc_speed}
\end{figure}

\section{Реализация подсистемы следования траектории}

Оставшимся компонентом системы управления движением беспилотного автомобиля является подсистеме следования по траектории,
т.е. регулятор с обратной связью. Назначение этой подсистемы заключается в том, чтобы осуществлять выполнение траекторий,
которые были сгенерированны подсистемой планирования движения, формируя последовательность управляющих сигналов для
актуаторов автомобиля. Чтобы избежать неизбежных отклонений от траектории, которые неизбежно возникнут в системе
открытого цикла, применяется обратная связь, использующая текущее состояние автомобиля для коррекции последовательности
команд. В данном случае, обратная связь осуществляется с помощью положения и ориентации автомобиля, получаемые от
ZED-камеры.

В данной работе для рулевого управления применяется регулятор с обратной связью, основанный на модели МакАдама
\hl{TODO: ссылка}. Иллюстрация работы регулятора с обратной связью приведена на рисунке \ref{img:path_moving}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{images/path_moving}
    \caption{Иллюстрация работы регулятора с обратной связью}
    \label{img:path_moving}
\end{figure}

Принцип работы этого алгоритма заключается в том, чтобы найти вектор $\vect{OV}$, соединяющий текущее положение
автомобиля $O$ с траекторией и использовать угол между текущим вектором скорости $\vec{v}$ и найденным вектором в
пропорциональном (П)-регуляторе, чтобы определить управляющие сигналы. Вектор $\vect{OV}$ выбирается таким образом,
чтобы он соединял текущее положение автомобиля с траекторией на неком удалении вперед от текущего положения автомобиля.
Это позволяет принимать во внимание будущие изменения траектории и начинать маневр заранее.

Вектор $\vect{OP}$ находится как точка пересечения окружности радиусом $R$ и траектории. Траектория представлена набором
опорных точек с малым расстоянием друг между другом. Это позволяет легко находить положение точки $P$ с точностью до
расстояния между двумя последовательными точками траектории. Возможно было бы повысить точность определения точки $P$
путем нахождения пересечения окружности с отрезком, образованном двумя ближайшими точками траектории, но это не
требуется.

Алгоритм работает следующим образом. Вначале находится точка $C$ траектории, ближайшая к текущему положению автомобиля
$O$. Затем от точки $C$ по направлению движения траектории отсчитываются точки до тех пор, пока очередная точка не будет
удалена от точки $O$ на расстояние больше, чем $R$. Это и будет искомая точка $P$. Угол $u$ вычисляется следующим
образом:

\begin{align}
    &\vec{v}\times\vect{OP} = \left|\vec{v}\right|\left|\vect{OP}\right|\sin u \\
    &\vec{v}\cdot \vect{OP} = \left|\vec{v}\right|\left|\vect{OP}\right|\cos u \\
\end{align}
\begin{equation}
    \tan u  = \frac{\vec{v}\times\vect{OP}}{\vec{v}\cdot \vect{OP}} =
              \frac{\left|\vec{v}\right|\left|\vect{OP}\right|\sin u}
                   {\left|\vec{v}\right|\left|\vect{OP}\right|\cos u} =
              \frac{\sin u}{\cos u} \\
\end{equation}
\begin{equation}
    u = atan2 \left(\vec{v}\times\vect{OP}, \vec{v}\cdot\vect{OP}\right)
\end{equation}


Где функция $atan2$ определена следующим образом:
\begin{equation}
    atan2(y,x) =
        \begin{cases}
            \arctan(\frac{y}{x}),       & \text{при $x > 0$}, \\
            \arctan(\frac{y}{x}) + \pi, & \text{при $x < 0$, $y \geq 0$}, \\
            \arctan(\frac{y}{x}) - \pi, & \text{при $x < 0$, $y < 0$}, \\
            +\frac{\pi}{2},             & \text{при $x = 0$, $y > 0$}, \\
            -\frac{\pi}{2},             & \text{при $x = 0$, $y < 0$}, \\
            \text{не определено},       & \text{при $x = 0$, $y = 0$}
        \end{cases}
\end{equation}

Использование такого выражения позволит получить значение угла со знаком во всех тригонометрических четвертях.
Знак угла используется для определения направления поворота (налево при $u > 0$ или направо при $u < 0$). Функция $atan2$ реализована в
стандартных математических библиотеках большинства языков программирования.

Т.к. мобильная платформа, на которой проводились эксперименты, обладает дифференциальным приводом, т.е. поворот
осуществляется за счет изменения скорости вращения колес левого и правого борта друг относительно друга, то
скорости вращения колес определяются на основе расчитанного угла $u$ с использованием пропорционального регулятора
следующим образом:
\begin{align}
    &left = speed + ku \\
    &right = speed - ku
\end{align}

Этот компонент реализован на языке Python 2.7 в виде ноды ROS path\_mover\_node. Нода подписывается на текущее состояние
автомобиля, получаемое от ZED-камеры /zed/pose и на локальную траекторию, сгенерированную планировщиком локального
движения (motion\_planner\_node) local\_path.

\section{Выводы по главе}

Были реализованы основные компоненты системы управления движением беспилотного автомобиля, которые были описаны
во второй главе.

Структура системы управления движением основывается на фреймворке ROS и использует его как связующий слой для модулей
встраиваемой системы управления.

Реализована подсистема планирования движения, согласно алгоритму, проектирование которого было описано во второй главе,
которая является основным результатом данной работы. Подсистема планирования движения позволяет планировать траектории,
позволяющие достичь локальной цели, избегая столкновения с препятствиями.
Реализован прототип системы компьютерного зрения для обнаружения препятствия с помощью LiDAR, используемые для
испытаний и отладки системы управления. Реализована подсистема удержания траектории в виде регулятора с обратной связью,
позволяющая двигаться по траекториям, сгенерированным подсистемой планирования движения. Реализован компонент
драйвера, позволяющий отправлять команды управления аппаратному обеспечению автомобиля.

Изготовлена мобильная колесная платформа, оснащенная датчиками системы компьютерного зрения, позволяющая производить
испытания и отладку системы управления автомобилем.